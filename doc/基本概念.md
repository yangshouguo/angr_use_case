# Core Concepts

## 1. Top Level Interfaces

### 1.1 `Project`

```python
>>> import angr
>>> proj = angr.Project('/bin/true')
```

### 1.2 Basic properties

#### 1.2.1 `filename` - `str`

被加载的二进制文件的路径字符串

#### 1.2.2 `loader` - `cle.Loader`

#### 1.2.3 `arch` - `archinfo.Arch`

#### 1.2.4 `entry` - `int`

`_start`函数在文件中的地址。

#### 1.2.5 `storage` - `defaultdict`

[defaultdict API](https://docs.python.org/2/library/collections.html?highlight=collections#module-collections)

[defaultdict简介blog](https://www.jb51.net/article/88147.htm)

#### 1.2.6 `store_function` 

值为：参数中传入的`store_function`或`_store`函数。

`self.store_function = store_function or self._store`

#### 1.2.7 `load_function`

值为：参数中传入的`load_function`或`_load`函数。

`self.load_function= load_functionor self._load`

#### 1.2.8 `engines` - `EngineHub`

#### 1.2.9 `factory` - `AngrObjectFactory`

#### 1.2.10 `analyses` - `AnalysesHub`

#### 1.2.11 `surveyors` - `Surveyors`

#### 1.2.12 `kb` - `KnowledgeBase`

#### 1.2.13 `simos` - `SimOS 子类：SimLinux / SimWindows/ SimCGC`

### 1.3 `Loader`

CLE模块模拟程序加载，结果为“Loader”。

```python
>>> proj.loader
<Loaded true, maps [0x400000:0x5004000]>

>>> proj.loader.shared_objects # may look a little different for you!
{'ld-linux-x86-64.so.2': <ELF Object ld-2.24.so, maps [0x2000000:0x2227167]>,
 'libc.so.6': <ELF Object libc-2.24.so, maps [0x1000000:0x13c699f]>}

>>> proj.loader.min_addr
0x400000
>>> proj.loader.max_addr
0x5004000

>>> proj.loader.main_object  # we've loaded several binaries into this project. Here's the main one!
<ELF Object true, maps [0x400000:0x60721f]>

>>> proj.loader.main_object.execstack  # sample query: does this binary have an executable stack?
False
>>> proj.loader.main_object.pic  # sample query: is this binary position-independent?
True
```

### 1.4 `Factory`

#### 1.4.1 `Blocks`

##### 1.4.1.1 `angr.block.Block`

`project.factory.block()`从指定地址中提取基本代码块（angr分析代码的单位）

```python
>>> block = proj.factory.block(proj.entry) # lift a block of code from the program's entry point
<Block for 0x401670, 42 bytes>

>>> block.pp()                          # pretty-print a disassembly to stdout
0x401670:       xor     ebp, ebp
0x401672:       mov     r9, rdx
0x401675:       pop     rsi
0x401676:       mov     rdx, rsp
0x401679:       and     rsp, 0xfffffffffffffff0
0x40167d:       push    rax
0x40167e:       push    rsp
0x40167f:       lea     r8, [rip + 0x2e2a]
0x401686:       lea     rcx, [rip + 0x2db3]
0x40168d:       lea     rdi, [rip - 0xd4]
0x401694:       call    qword ptr [rip + 0x205866]

>>> block.instructions                  # how many instructions are there?
0xb
>>> block.instruction_addrs             # what are the addresses of the instructions?
[0x401670, 0x401672, 0x401675, 0x401676, 0x401679, 0x40167d, 0x40167e, 0x40167f, 0x401686, 0x40168d, 0x401694]

>>> block.capstone                       # capstone disassembly
<CapstoneBlock for 0x401670>
>>> block.vex                            # VEX IRSB (that's a python internal address, not a program address)
<pyvex.block.IRSB at 0x7706330>
```

**Properties**

1. `arch` - ``archinfo.Arch``

2. `thumb` - `bool`

   ```python
   if isinstance(self.arch, ArchARM):
       if addr & 1 == 1:
           thumb = True
       elif thumb:
           addr |= 1
   else:
       thumb = False
   ```

3. `addr` - `int`

   构造函数传入的参数`addr`（唯一必须参数，其他参数均有默认值）

4. `size` - `int`

   ????

5. `instructions` - `int`

   该基本块中有多少条指令（汇编语句）

6. `instructions_addrs` - `list{long}`

   该基本块中指令地址列表

7. `_vex_engine` - `SimEngineVEX`

8. `vex` - `IRSB`

   ？？？？

9. `vex_nostmt` - `IRSB`

10. `capstone` - `CapstoneBlock`

    ？？？？

11. `codenode` - `BlockNode`

    ？？？？

12. `bytes` - `str`

    ?????

**functions**

1. `pp()` - `str`

   返回指令汇编代码

#### 1.4.2 `States`

```python
>>> state = proj.factory.entry_state()
<SimState @ 0x401670>
```

`SimState`包含程序的内存、寄存器、文件系统数据等任何可以通过执行更改的数据。

```python
>>> state.regs.rip        # get the current instruction pointer
<BV64 0x401670>
>>> state.regs.rax
<BV64 0x1c>
>>> state.mem[proj.entry].int.resolved  # interpret the memory at the entry point as a C int
<BV32 0x8949ed31>

>>> bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234
<BV32 0x1234>                               # BVV stands for bitvector value
>>> state.solver.eval(bv)                # convert to python int
0x1234

>>> state.regs.rsi = state.solver.BVV(3, 64)
>>> state.regs.rsi
<BV64 0x3>

>>> state.mem[0x1000].long = 4
>>> state.mem[0x1000].long.resolved # Use .resolved to get the value as a bitvector
<BV64 0x4>
>>> state.mem[0x1000].long.concrete # Use .concrete to get the value as a python int
0x4

>>> state.regs.rdi
<BV64 reg_48_11_64{UNINITIALIZED}> # 符号变量
```

**Properties**

1. `project` - `Project`

2. `arch` - `archinfo.Arch`

3. `mode` - `str`

   传入的`mode`参数，若未传入，为`'symbolic'`

4. `os_name` - `str`

5. `uninitialized_access_handler` - `None`(默认为None)

   ？？？？

6. `ip_constraints` - `list`

   ？？？？

7. `plugins` - `dict`

   ？？？？

8. `se` - `SimSolver`

   ？？？？

9. `ip` - `BV`

   `return self.regs.ip`

   有`setter`方法

10. `_ip` - `BV`

    返回值实质上与`ip`相同

    `return self.regs._ip`

    有`setter`方法

11. `addr` - `long`

    返回基本块地址？

12. `options` - `SimStateOptions`

    ？？？？

    有`setter`方法

13. `thumb` - `bool`

    ？？？？

14. `with_condition` - `angr.sim_state下的函数ctx(c)`

    ？？？？

15. `state` - `SimState`

    返回自身

16. `length` - `int`

    `return self.history.block_count`

17. `jumpkind` - `str`

    ``return self.history.jumpkind``

18. `last_actions` - `list`

    ``return self.history.recent_actions``

19. `history_iterator` - `Historyiter`

    ``return self.history.lineage``

20. `addr_trace` - `Lambdaiteriter`

    ``return self.history.addr_trace``

21. `trace` - `LambdaAttriter`

    ？？？？

22. `targets` - `LambdaAttriter`

23. `guards` -  `LambdaAttriter`

24. `jumpkinds` -  `LambdaAttriter`

25. `events` - `Lambdaiteriter`

26. `actions` - `Lambdaiteriter`

27. `reachable` - `bool`

28. `history` - `SimStateHistory`

29. `regs` - `SimRegNameView`

30. `registers` - `SimSymbolicMemory`

#### 1.4.3 `Simulation Managers`

```python
>>> simgr = proj.factory.simulation_manager(state)
<SimulationManager with 1 active>
>>> simgr.active # 后续基本块的起始地址
[<SimState @ 0x401670>]

>>> simgr.step()

>>> simgr.active
[<SimState @ 0x1020300>]
>>> simgr.active[0].regs.rip                 # new and exciting!
<BV64 0x1020300>
>>> state.regs.rip                           # still the same!
<BV64 0x401670>
```

**Properties**

1. `ana_uuid` - `str`
2. `active` - `list{SimState}`
3. `DROP` - `str`
4. `unconstrained` - `list`
5. `pruned` - `list`
6. `deadended`- `list`
7. `stashed` - `list`
8. `stashes` - `defaultdict`
9. `errored` - `list`
10. `ALL`  - `str`
11. `unsat` - `list`

### 1.5 `Analyses`

```python
# Originally, when we loaded this binary it also loaded all its dependencies into the same virtual address  space
# This is undesirable for most analysis.
>>> proj = angr.Project('/bin/true', auto_load_libs=False)
>>> cfg = proj.analyses.CFGFast()
<CFGFast Analysis Result at 0x2d85130>

# cfg.graph is a networkx DiGraph full of CFGNode instances
# You should go look up the networkx APIs to learn how to use this!
>>> cfg.graph
<networkx.classes.digraph.DiGraph at 0x2da43a0>
>>> len(cfg.graph.nodes())
951

# To get the CFGNode for a given address, use cfg.get_any_node
>>> entry_node = cfg.get_any_node(proj.entry)
>>> len(list(cfg.graph.successors(entry_node)))
2
```

## 2. Loading a Binary

[CLE API](http://angr.io/api-doc/cle.html)

#### 2.1 `Loader`

```python
>>> import angr, monkeyhex
>>> proj = angr.Project('/bin/true')
>>> proj.loader
<Loaded true, maps [0x400000:0x5008000]>
```

#### 2.2 `Loaded Objects`

```python
# All loaded objects
>>> proj.loader.all_objects
[<ELF Object fauxware, maps [0x400000:0x60105f]>,
 <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>,
 <ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]>,
 <ELFTLSObject Object cle##tls, maps [0x3000000:0x300d010]>,
 <KernelObject Object cle##kernel, maps [0x4000000:0x4008000]>,
 <ExternObject Object cle##externs, maps [0x5000000:0x5008000]>

# This is the "main" object, the one that you directly specified when loading the project
>>> proj.loader.main_object
<ELF Object true, maps [0x400000:0x60105f]>

# This is a dictionary mapping from shared object name to object
>>> proj.loader.shared_objects
{ 'libc.so.6': <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>
  'ld-linux-x86-64.so.2': <ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]>}

# Here's all the objects that were loaded from ELF files
# If this were a windows program we'd use all_pe_objects!
>>> proj.loader.all_elf_objects
[<ELF Object true, maps [0x400000:0x60105f]>,
 <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>,
 <ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]>]

# Here's the "externs object", which we use to provide addresses for unresolved imports and angr internals
>>> proj.loader.extern_object
<ExternObject Object cle##externs, maps [0x5000000:0x5008000]>

# This object is used to provide addresses for emulated syscalls
>>> proj.loader.kernel_object
<KernelObject Object cle##kernel, maps [0x4000000:0x4008000]>

# Finally, you can to get a reference to an object given an address in it
>>> proj.loader.find_object_containing(0x400000)
<ELF Object true, maps [0x400000:0x60105f]>
```

直接从中取出元数据：

```python
>>> obj = proj.loader.main_object

# The entry point of the object
>>> obj.entry
0x400580

>>> obj.min_addr, obj.max_addr
(0x400000, 0x60105f)

# Retrieve this ELF's segments and sections
>>> obj.segments
<Regions: [<ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74>,
           <ELFSegment offset=0xe28, flags=0x6, filesize=0x228, vaddr=0x600e28, memsize=0x238>]>
>>> obj.sections
<Regions: [<Unnamed | offset 0x0, vaddr 0x0, size 0x0>,
           <.interp | offset 0x238, vaddr 0x400238, size 0x1c>,
           <.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20>,
            ...etc

# You can get an individual segment or section by an address it contains:
>>> obj.find_segment_containing(obj.entry)
<ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74>
>>> obj.find_section_containing(obj.entry)
<.text | offset 0x580, vaddr 0x400580, size 0x338>

# Get the address of the PLT stub for a symbol
>>> addr = obj.plt['abort']
>>> addr
0x400540
>>> obj.reverse_plt[addr]
'abort'

# Show the prelinked base of the object and the location it was actually mapped into memory by CLE
>>> obj.linked_base
0x400000
>>> obj.mapped_base
0x400000
```

`prelink`  ？？？

#### 2.3 `Symbols and Relocations`

```python
>>> malloc = proj.loader.find_symbol('malloc')
>>> malloc
<Symbol "malloc" in libc.so.6 at 0x1054400>
```

```python
>>> malloc.name
'malloc'

>>> malloc.owner_obj
<ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>

>>> malloc.rebased_addr  # 在全局地址空间中的地址
0x1054400
>>> malloc.linked_addr	# 相对于二进制预链接库的地址
0x54400
>>> malloc.relative_addr  # 相对于object基地址的地址（Windows中成为RVA相对虚拟地址）
0x54400
```

```python
>>> malloc.is_export
True
>>> malloc.is_import
False

# On Loader, the method is find_symbol because it performs a search operation to find the symbol.
# On an individual object, the method is get_symbol because there can only be one symbol with a given name.
>>> main_malloc = proj.loader.main_object.get_symbol("malloc")
>>> main_malloc
<Symbol "malloc" in true (import)>
>>> main_malloc.is_export
False
>>> main_malloc.is_import
True
>>> main_malloc.resolvedby
<Symbol "malloc" in libc.so.6 at 0x1054400>
```

```python
# Relocations don't have a good pretty-printing, so those addresses are python-internal, unrelated to our program
>>> proj.loader.shared_objects['libc.so.6'].imports
{u'__libc_enable_secure': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4221fb0>,
 u'__tls_get_addr': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x425d150>,
 u'_dl_argv': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4254d90>,
 u'_dl_find_dso_for_object': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x425d130>,
 u'_dl_starting_up': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x42548d0>,
 u'_rtld_global': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4221e70>,
 u'_rtld_global_ro': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4254210>}
```

如果导入无法解析为任何导出，例如，因为找不到共享库，CLE将自动更新externs对象（loader.extern_obj）以声明它将符号作为导出。  ？？？？

#### 2.4 `Loading Options`

##### 2.4.1 `Basic Options`

- `auto_load_libs` - 启用或禁用CLE尝试自动解析共享库依赖项，默认情况下启用。
- `except_missing_libs` - 设置为`true`，只要二进制文件具有无法解析的共享依赖库项，会引发异常。
- `force_load_libs` - 字符串列表，都被视为未解析的共享依赖项。
- `skip_libs` - 字符串列表，都不会被解析为依赖项。
- `custom_ld_path` - 字符串列表或单个字符串，用作共享库的附加搜索路径（在默认搜索路径之前）（默认搜索路径：被加载的程序目录、当前工作目录、系统库）。

##### 2.4.2 `Per-Binary Options`

可以指定仅适用于特定二进制对象的某些选项。

- `main_opts` ：`dict`，从选项名称到选项值的映射。如：`main_opts={'backend':'ida', 'custom_arch':'i386'}`
- `lib_opts` ： `dict`，从库名称到字典的映射。如：`lib_opts={'libc.so.6': {'backend': 'elf'}}`

常用选项：

- `backend` - 指定使用哪个后端，可以类或名字(`str`)
- `custom_base_addr` - 基地址
- `custom_entry_point` - 入口点
- `custom_arch` - 体系结构的名字

##### 2.4.3 `Backends`

CLE有可静态加载ELF、PE、CGC、Mach-O、ELF核心转储文件的后端，也可以使用IDA加载二进制文件，并将文件加载到平面地址空间。通常不需要指定使用哪个后端，CLE会自动检测正确的后端。

某些后端无法自动检测要使用的体系结构，并且必须指定`custom_arch`。字典中的`key`不需要匹配任何体系结构的列表。 ？？？？

| backend name | description                                                  | requires `custom_arch`? |
| ------------ | ------------------------------------------------------------ | ----------------------- |
| elf          | Static loader for ELF files based on PyELFTools              | no                      |
| pe           | Static loader for PE files based on PEFile                   | no                      |
| mach-o       | Static loader for Mach-O files. Does not support dynamic linking or rebasing. | no                      |
| cgc          | Static loader for Cyber Grand Challenge binaries             | no                      |
| backedcgc    | Static loader for CGC binaries that allows specifying memory and register backers | no                      |
| elfcore      | Static loader for ELF core dumps                             | no                      |
| ida          | Launches an instance of IDA to parse the file                | yes                     |
| blob         | Loads the file into memory as a flat image                   | yes                     |

#### 2.5 `Symbolic Function Summaries`

默认情况下，`Project`尝试使用`SimProcedures`的符号摘要替换对**库函数**的外部调用 - 实际上只是模仿库函数对状态的影响的python函数。

内置`procedures`可以在`angr.SIM_PROCEDURES`字典中找到，该字典是两层的，第一层键为**包名称**（`libc，posix，win32，stubs`），第二层为库函数名称。

执行`SimProcedure`而不是从系统加载的实际库函数使得分析更容易处理，代价是一些**潜在的不准确性**。 

当给定的函数没有对应的摘要时：

- `auto_load_libs` - 若为`True`（默认值），执行实际库函数。（可能会导致路径状态数量激增）
- `auto_load_libs` - 若为`False`，`Project`将其解析为名为`ReturnUnconstrained`的通用“stub” `SimProceure`。 每次调用时会返回一个唯一的无约束符号值。 ？？？？
- `use_sim_procedures` - `angr.Project`的参数，默认为`True`。若为`False`，则`extern`对象提供的符号会被`SimProcedures`替换，并被存储为一个只返回一个符号值的stub `ReturnUnconstrained`。
- `exclude_sim_procedures_list` 和 `exclude_sim_procedures_func`指定不用`SimProcedures`替换的函数。

`angr.Project._register_object`确切算法。？？？？

##### 2.5.1 `Hooking`

执行模拟时，每一步都会检查当前地址是否已经被hook，若被hook，则执行hook的函数。

`proj.hook(addr, hook)`

```python
>>> stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # this is a CLASS
>>> proj.hook(0x10000, stub_func())  # hook with an instance of the class

>>> proj.is_hooked(0x10000)            # these functions should be pretty self-explanitory
True
>>> proj.unhook(0x10000)
>>> proj.hooked_by(0x10000)
<ReturnUnconstrained>

>>> @proj.hook(0x20000, length=5)
... def my_hook(state):
...     state.regs.rax = 1

>>> proj.is_hooked(0x20000)
True
```

`proj.hook_symbol(name, hook)`，第一个参数是符号名。

可以对`angr`内置的`SimProcedures`进行扩展，对其子类化，覆盖其行为，在hook中使用子类。

## 3. Solver Engine

**符号表示与约束求解**

符号执行生成抽象语法树AST，转换为SMT求解器的约束，进行约束求解。

#### 3.1 `Bitvector`

```python
>>> import angr, monkeyhex

>>> proj = angr.Project('/bin/true')
>>> state = proj.factory.entry_state()
```

```python
# 64-bit bitvectors with concrete values 1 and 100
>>> one = state.solver.BVV(1, 64)
>>> one
 <BV64 0x1>
>>> one_hundred = state.solver.BVV(100, 64)
>>> one_hundred
 <BV64 0x64>

# create a 27-bit bitvector with concrete value 9
>>> weird_nine = state.solver.BVV(9, 27)
>>> weird_nine
<BV27 0x9>
```

```python
>>> one + one_hundred
<BV64 0x65>

# You can provide normal python integers and they will be coerced to the appropriate type:
>>> one_hundred + 0x100
<BV64 0x164>

# The semantics of normal wrapping arithmetic apply
>>> one_hundred - one*200
<BV64 0xffffffffffffff9c>
```

不同长度的位向量进行算数运算会出错。可以将其中较短的向量进行长度扩展。

```python
>>> weird_nine.zero_extend(64 - 27)
<BV64 0x9>
>>> one + weird_nine.zero_extend(64 - 27)
<BV64 0xa>
```

`zero_extend`使用给定位数的零填充左侧的位向量。`sign_extend`填充最高位的副本，在两个符号有符号整数语义下保留位向量的值。 

类似于0扩展和符号扩展。

```python
# Create a bitvector symbol named "x" of length 64 bits
>>> x = state.solver.BVS("x", 64)
>>> x
<BV64 x_9_64>
>>> y = state.solver.BVS("y", 64)
>>> y
<BV64 y_10_64>
```

符号变量运算得到AST。

```python
>>> x + one
<BV64 x_9_64 + 0x1>

>>> (x + one) / 2
<BV64 (x_9_64 + 0x1) / 0x2>

>>> x - y
<BV64 x_9_64 - y_10_64>
```

`bitvector`相当于是一个只有一层的AST。

每个AST都有一个`.op`和一个`.args`。`op`是一个命名正在执行的操作的**字符串**，`args`是`op`操作符的操作数。

```python
>>> tree = (x + 1) / (y + 2)
>>> tree
<BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)>
>>> tree.op
'__div__'
>>> tree.args
(<BV64 x_9_64 + 0x1>, <BV64 y_10_64 + 0x2>)
>>> tree.args[0].op
'__add__'
>>> tree.args[0].args
(<BV64 x_9_64>, <BV64 0x1>)
>>> tree.args[0].args[1].op
'BVV'
>>> tree.args[0].args[1].args
(1, 64)
```

#### 3.2 符号约束

相似类型的AST执行比较操作将产生另一个AST（符号布尔值）

```python
>>> x == 1
<Bool x_9_64 == 0x1>
>>> x == one
<Bool x_9_64 == 0x1>
>>> x > 2
<Bool x_9_64 > 0x2>
>>> x + y == one_hundred + 5
<Bool (x_9_64 + y_10_64) == 0x69>
>>> one_hundred > 5
<Bool True>
>>> one_hundred > -5  # 无符号数比较
<Bool False>
```

默认情况下，是当做无符号数比较。若比较带符号数，可以使用`one_hunder.SGT(-5)`

在if或while语句的条件中，不能直接使变量之间的比较（会引发异常）

应该使用`solver.is_true`和`solver.is_false`，可以在不执行约束求解的情况下判断真假。

```python
>>> yes = one == 1
>>> no = one == 2
>>> maybe = x == y
>>> state.solver.is_true(yes)
True
>>> state.solver.is_false(yes)
False
>>> state.solver.is_true(no)
False
>>> state.solver.is_false(no)
True
>>> state.solver.is_true(maybe)  # 符号值的比较，无法判断真假，结果为假 ？？？？
False
>>> state.solver.is_false(maybe)
False
```

#### 3.3 约束求解

将符号变量的比较表达式作为约束添加到state，通过`eval`求解出符号变量的有效值。

```python
>>> state.solver.add(x > y)
>>> state.solver.add(y > 2)
>>> state.solver.add(10 > x)
>>> state.solver.eval(x)
4
```

```python
# get a fresh state without constraints
>>> state = proj.factory.entry_state()
>>> input = state.solver.BVS('input', 64)
>>> operation = (((input + 4) * 3) >> 1) + input
>>> output = 200
>>> state.solver.add(operation == output)
>>> state.solver.eval(input)
0x3333333333333381
```

```python
>>> state.solver.add(input < 2**32)
>>> state.satisfiable()  # 检查state的可满足性
False
```

```python
# fresh state
>>> state = proj.factory.entry_state()
>>> state.solver.add(x - y >= 4)
>>> state.solver.add(y > 0)
>>> state.solver.eval(x)
5
>>> state.solver.eval(y)
1
>>> state.solver.eval(x + y)
6
```

`eval`求解出的结果是python中数据类型（`int，long`等），不是`bitvector`

#### 3.4 浮点数

z3支持IEEE754浮点数的理论 。

```python
# fresh state
>>> state = proj.factory.entry_state()
>>> a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE)
>>> a
<FP64 FPV(3.2, DOUBLE)>

>>> b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE)
>>> b
<FP64 FPS('FP_b_0_64', DOUBLE)>

>>> a + b
<FP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))>

>>> a + 4.4
<FP64 FPV(7.6000000000000005, DOUBLE)>

>>> b + 2 < 0  # fp操作，如solver.fpAdd，第一个参数指定舍入模式（solver.fp.RM_*） ？？？？
<Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))>
```

```python
>>> state.solver.add(b + 2 < 0)
>>> state.solver.add(b + 2 > -1)
>>> state.solver.eval(b)
-2.4999999999999996
```

`raw_bo_fp`将`bitvectors`解释为浮点数，`raw_to_bv`将浮点数解释为`bitvector`

```python
>>> a.raw_to_bv()
<BV64 0x400999999999999a>
>>> b.raw_to_bv()
<BV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))>

>>> state.solver.BVV(0, 64).raw_to_fp()
<FP64 FPV(0.0, DOUBLE)>
>>> state.solver.BVS('x', 64).raw_to_fp()
<FP64 fpToFP(x_1_64, DOUBLE)>
```

上述转换保留了**位模式**，就像将浮点指针转换为`int`指针一样。

如果要尽可能保留值，像将`float`转换为`int`，则可以使用另一组方法`val_to_fp`和`val_to_bv`。由于浮点数的浮点特性，这些方法必须**将目标值的大小或种类作为参数**。这些方法也可以采用带符号的参数，指定源或目标位向量的符号。  ？？？？

```python
>>> a
<FP64 FPV(3.2, DOUBLE)>
>>> a.val_to_bv(12)
<BV12 0x3>
>>> a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT)  # ？？？？
<FP32 FPV(3.0, FLOAT)>
```

#### 3.5 `solver`的一些方法

- `solver.eval(expression)`提供给定表达式的一种可能解决方案。 

- `solver.eval_one(expression)`提供给定表达式的解决方案，如果有多个解决方案则抛出错误。 

- `solver.eval_upto(expression，n)`提供最多n个给定表达式的解，如果可能少于n，则返回所有可能的解。

- `solver.eval_atleast(expression，n)`提供给定表达式的n个解决方案，如果可能少于n则抛出错误。 

- `solver.eval_exact(expression，n)`提供给定表达式的n个解决方案，如果少于或多于n，则抛出错误。 

- `solver.min(expression)`提供给定表达式的最小可能解决方案。 

- `solver.max(expression)`提供给定表达式的最大可能解决方案。 

上述方法均可以使用以下关键字参数：

- `extra_constraints`：由约束组成的元组。
- `cast_to`：该方法返回基础数据的字节表示。例如：`state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)`将会返回"ABCD"。

## 4. Program State

```python
>>> import angr, claripy
>>> proj = angr.Project('/bin/true')
>>> state = proj.factory.entry_state()

# copy rsp to rbp
>>> state.regs.rbp = state.regs.rsp

# store rdx to memory at 0x1000
>>> state.mem[0x1000].uint64_t = state.regs.rdx

# dereference rbp
>>> state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved

# add rax, qword ptr [rsp + 8]
>>> state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved
```

### 4.1 Basic Execution

`state.step()`方法将执行符号执行的一个步骤，并返回一个名为`SimSuccessors`的对象。此对象的.successors属性，该属性是包含给定步骤的所有“正常”后继者的列表 。

```python
>>> proj = angr.Project('examples/fauxware/fauxware')
>>> state = proj.factory.entry_state(stdin=angr.SimFile)  # ignore that argument for now - we're disabling a more complicated default setup for the sake of education
>>> while True:
...     succ = state.step()
...     if len(succ.successors) == 2:
...         break
...     state = succ.successors[0]

>>> state1, state2 = succ.successors
>>> state1
<SimState @ 0x400629>
>>> state2
<SimState @ 0x400699>
```

```python
>>> input_data = state1.posix.stdin.load(0, state.posix.stdin.size)

>>> state1.solver.eval(input_data, cast_to=str)
'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'

>>> state2.solver.eval(input_data, cast_to=str)
'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'
```

### 4.2 State Presets

创建`state`的构造方法：

- `.blank_state()` 构造一个**空白状态**，大部分数据未初始化。访问未初始化的数据，将返回无约束符号值。
- `.entry_state()` 构造一个准备在主二进制文件入口点执行的状态。
- `.full_init_state()` 构造一个状态，该状态可以通过任何需要在主二进制文件入口点之前运行的初始化程序执行，例如：共享库构造函数或预初始化程序。执行完成后，将跳转到入口点。
- `.call_state()` 构造一个准备执行给定函数的状态。

构造函数参数（自定义`state`）:

- `addr`：指定要启动的确切地址
- `args`和`env`：`agrs`为参数`list`，`env`为环境变量`dict`，可以传递给`entry_state`和`full_init_state`两个构造函数，（**命令行**传递）。其中的值可以是字符串或位向量，将会作为模拟执行的参数和环境序列化到`state`中。默认的`args`是一个**空的`list`**。
- `args：`如果让`argc`成为符号，可以将符号位向量作为`argc`传递给`entry_state`和`full_init_state`构造函数。但是要小心：如果这样做，还应该在结果状态中添加一个约束，使得`argc`的值不能大于传递给`args`的`args`数。 
- 要使用调用状态，应该使用`.call_state(addr，arg1，arg2，...)`来调用它，其中`addr`是要调用的函数的地址，而`argN`是该函数的第`N`个参数，或者作为python整数，字符串或数组，或`bitvector`。 如果想分配内存并实际传入指向对象的指针，你应该将它包装在`PointerWrappe`r中，即`angr.PointerWrapper("point to me!")`。**这个API的结果可能有点不可预测**。  ？？？？
- 要使用`call_state`指定用于函数的调用约定，可以将`SimCC`实例作为`cc`参数传递。  ？？？？

### 4.3 Low level interface for memory

```python
>>> s = proj.factory.blank_state()
>>> s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))
>>> s.memory.load(0x4004, 6) # load-size is in bytes
<BV48 0x89abcdef0123>
```

数据以“`big-endian`”方式加载和存储，因为`state.memory`的主要目的是加载没有附加语义的存储数据。

但是，如果要对加载或存储的数据执行`byteswap`，则可以传递关键字参数`endness` - 如果指定`little-endian`，则会发生`byteswap`。 `endness`应该是`archinfo`包中`Endness`枚举的成员之一，用于保存有关`ang`r的CPU体系结构的声明性数据。

此外，正在分析的程序的大小端属性可以在`arch.memory_endness`中找到 - 例如`state.arch.memory_endness `

```python
>>> import archinfo
>>> s.memory.load(0x4000, 4, endness=archinfo.Endness.LE) # 以小端方式load，长度为4字节
<BV32 0x67453201>
```

还有一个用于寄存器访问的低级接口`state.registers`，它使用与`state.memory`**完全相同**的API，但解释其行为涉及深入了解`angr`用于与多个体系结构无缝协作的抽象。简单来说，它只是一个寄存器文件，在`archinfo`中定义了寄存器和偏移之间的映射。 ？？？？

### 4.4 State Options

`state.options`是`SimState`对象的一个属性，是一个`set`，保存有所有已启用选项（字符串），以某种微小的方式控制`angr`执行引擎的行为。

可以通过`angr.options`访问单个选项来添加到`state`，各个选项以`CAPITAL_LETTERS`命名，也有一些常见的对象分组用于捆绑在一起的选项，使用`lowercase_letter`命名。

通过任何构造函数创建`SimState`时，可以传递关键字参数`add_options`和`remove_options`，这些参数都是`set`，可以修改默认的选项`set`。

```python
# Example: enable lazy solves, an option that causes state satisfiability to be checked as infrequently as possible.
# This change to the settings will be propagated to all successor states created from this state after this line.
>>> s.options.add(angr.options.LAZY_SOLVES)

# Create a new state with lazy solves enabled
>>> s = proj.factory.entry_state(add_options={angr.options.LAZY_SOLVES})

# Create a new state without simplification options enabled
>>> s = proj.factory.entry_state(remove_options=angr.options.simplification)
```

### 4.5 State Plugins

除了`.options`之外，存储在`SimState`中的所有内容实际上都存储在附加到状态的插件中。 内存，寄存器，`mem`，`regs`，求解器等。这种设计允许代码模块化以及为其他方面轻松实现新类型数据存储的能力模拟状态，或提供插件的替代实现的能力。

例如，`memory`插件模拟平面内存空间，但分析可以选择启用“抽象内存”插件，该插件使用地址的备用数据类型来模拟独立于地址的自由浮动内存映射，以提供`state.memory`。插件可以降低代码复杂性：`state.memory`和`state.registers`实际上是同一个插件的两个不同实例，因为**寄存器也是用地址空间模拟的**。 

#### 4.5.1 `globals`

`state.globals`是一个非常简单的插件：它实现了标准python `dict`的接口，允许在状态中存储任意数据 。

#### 4.5.2 `history`

`state.history`是一个**非常重要**的插件，存储有关状态在执行期间所采用的路径的历史数据。它**实际上是几个历史节点的链表，每个节点代表一轮执行**---可以使用`state.history.parent.parent`等遍历此列表。

为了方便使用，`history`还提供了几个确切值的迭代器。通常，这些值存储为history.recent_NAME，迭代器只是history.NAME。例如，`for addr in state.history.bbl_addrs: print hex(addr)`将打印出二进制的基本块地址trace。`state.history.recent_bbl_addrs`是在最近的步骤中执行的基本块列表。 `history.parent.recent_bbl_addrs`是上一步骤中执行的基本块的列表，等等。

如果需要快速获取这些值的平面列表，则可以访问`.hardcopy`，例如`state.history.bbl_addrs.hardcopy`。**基于索引的访问是通过`interators`实现的**。  

`history`中的某些常用值：

- `history.descriptions`是对状态执行的每轮执行的字符串描述的列表。 
- `history.bbl_addrs`是状态执行的基本块地址的列表。每轮执行可能不止一个，并且并非所有地址都可能对应于二进制代码 - 有些可能是被`hook`的`SimProcedures`地址。 
- `history.jumpkinds`是状态历史中每个控制流转换的处置列表，是VEX枚举字符串 。
- `history.guards`是保护`state`遇到的每个分支的条件列表。 **似乎应该是`history.jump_guards`**
- `history.events`是在执行期间发生的“有趣事件”的语义列表，例如符号跳转条件的存在，程序弹出消息框，或带有退出代码的执行终止。 ？？？？
- `history.actions`通常为空，但如果将`angr.options.refs`选项添加到状态，则会弹出程序执行的所有内存，寄存器和临时值访问的日志。 ？？？？

#### 4.5.3 `callstack`

angr将跟踪模拟程序的调用堆栈。在每个调用指令上，一个帧将被添加到被跟踪的callstack的顶部，每当堆栈指针下降到被调用的最顶层帧的点之下时，就会弹出一个帧。这允许angr稳健地存储当前模拟功能的本地数据。 

与`history`类似，`callstack`也是节点的链表，但是没有提供节点内容的迭代器 - 而是可以直接迭代`state.callstack`来获取每个活动帧的`callstack`帧，顺序是从最近到最旧。如果你只想要最顶层的帧，那就是`state.callstack`。

- `callstack.func_addr`是当前正在执行的函数的地址 
- `callstack.call_site_addr`是调用当前函数的基本块的地址 (`call指令的地址`？？？？)
- `callstack.stack_ptr`是从当前函数开始的堆栈指针的值 （？？？？）
- `callstack.ret_addr`是当前函数返回时将返回的位置 （**返回地址**）

### 4.6 I/O

### 4.7 Copying and Merging

**Copy**

```python
>>> proj = angr.Project('/bin/true')
>>> s = proj.factory.blank_state()
>>> s1 = s.copy()
>>> s2 = s.copy()

>>> s1.mem[0x1000].uint32_t = 0x41414141
>>> s2.mem[0x1000].uint32_t = 0x42424242
```

**Merge**

```python
# merge will return a tuple. the first element is the merged state
# the second element is a symbolic variable describing a state flag
# the third element is a boolean describing whether any merging was done
>>> (s_merged, m, anything_merged) = s1.merge(s2) # merge出错？？？？

# this is now an expression that can resolve to "AAAA" *or* "BBBB"
>>> aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t
```

## 5. Simulation Managers

`state`组织成`stashes`。

### 5.1 `Stepping`

```python
>> import angr
>>> proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False)
>>> state = proj.factory.entry_state()
>>> simgr = proj.factory.simgr(state)
>>> simgr.active
[<SimState @ 0x400580>]

>>> simgr.step() # 执行一个基本块？？？？
>>> simgr.active
[<SimState @ 0x400540>]
```

当状态遇到符号分支条件时，两个后继状态都出现在存储中，并且可以同步两个状态。如果不关心控制分析，只想执行到到没有任何步骤，可以使用`.run()`方法。

```python
# Step until the first symbolic branch
>>> while len(simgr.active) == 1:
...    simgr.step()

>>> simgr
<SimulationManager with 2 active>
>>> simgr.active
[<SimState @ 0x400692>, <SimState @ 0x400699>]

# Step until everything terminates
>>> simgr.run()
>>> simgr
<SimulationManager with 3 deadended> 
```

当一个`state`在执行期间未能产生任何后继者时，例如，它到达了一个`exit`系统调用，它将从`active stash`中删除并放置在`deadended stash`中。 

### 5.2 `Stash Management`

在`stashes`之间移动`states`使用`.use()`，包括`from_stash`、`to_stash`、`filter_func`（可选，默认是移动everything）等选项。

```python
>>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: 'Welcome' in s.posix.dumps(1))  # ？？？？
>>> simgr
<SimulationManager with 2 authenticated, 1 deadended>
```

每个`stash`只是一个`list`，可以索引或迭代列表以访问每个单独的`state`，也有一些替代方法来访问状态。如果使用`one_`前置`stash`的名称，将获得`stash`中第一个`state`。如果使用`mp_`前缀`stash`的名称，将获得一个`mulpyplexed`版本的`stash`。

```python
>>> for s in simgr.deadended + simgr.authenticated:
...     print hex(s.addr)
0x1000030
0x1000078
0x1000078

>>> simgr.one_deadended
<SimState @ 0x1000030>
>>> simgr.mp_authenticated
MP([<SimState @ 0x1000078>, <SimState @ 0x1000078>])
>>> simgr.mp_authenticated.posix.dumps(0)
MP(['\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00',
    '\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00'])
```

 [Simulation Manager API](http://angr.io/api-doc/angr.html#module-angr.sim_manager)

### 5.3 Stash types

用于分类某些特殊`state`的`stash`：

| `Stash`         | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| `active`        | 除非指定了备用`stash`，否则此存储包含默认步进的`states`。    |
| `deadended`     | 当`state`由于某种原因无法继续执行时，转到`deadended stash`，包括没有更多有效指令，所有后继的状态不足(`successors`)或指令指针无效。 |
| `pruned`        | 使用`LAZY_SOLVES`时，除非绝对必要，否则不会检查`state`是否满足。当在`LAZY_SOLVES`存在时发现某个`state`不可满足，遍历状态层次结构以识别该`state`的`history`上最初变得不可满足的`state`。作为其的后代的所有`state`（也将是不饱和的，因为一个`state`不会变成非不可满足状态）是`pruned`并放入这个`stash`中。 |
| `unconstrained` | 如果向`SimulationManager`构造函数提供`save_unconstrained`选项，则确定为不受约束的状态（即，由用户数据或某些其他符号数据源控制的指令指针）放置在此处 |
| `unsat`         | 如果向`SimulationManager`构造函数提供`save_unsat`选项，则确定为不可满足的状态（即，它们具有相互矛盾的约束，例如输入必须同时为“AAAA”和“BBBB”） 。 |

还有另一个状态列表不是`stash`：`errored`。如果在执行期间出现错误，则`state`将被包装在`ErrorRecord`对象中，该对象包含`state`及其抛出的错误，然后该记录将插入到`errored`中。可以在执行开始时获取`state`，因为它导致了`record.state`的错误，可以看到`record.error`引发的错误，并且可以使用`record.debug()`，在该站点上启动`debug shell`。？？？？ 

### 5.4 Simple Exporation

符号执行中极为常见的操作是找到到达某个地址的状态，同时丢弃通过其他地址的所有状态。模拟管理器具有此模式的快捷方式，即`.explore()`方法。

 当使用`find`参数启动`.explore()`时，执行将一直运行，直到找到与`find`条件匹配的`state`，该条件可以是要停止的指令的地址，要停止的地址列表或者一个函数（获取一个`state`并返回它是否符合某些标准）。当`active stash`中的任何`state`与`finde`条件匹配时，这些`state`将被放置在`found stash`(`list`)中，并且执行终止。还可以使用与`find`相同的格式指定`avoid`条件。当`state`与`avoid`条件匹配时，将会存储在`avoided stash`中，并继续执行。最后，`num_find`参数控制返回之前应该找到的`state`数，默认值为`1`.当然，如果在找到这么多解决方案之前在`active stash`中运行完了状态，则执行将终止。

 ```python
>>> proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a')

>>> simgr = proj.factory.simgr()
>>> simgr.explore(find=lambda s: "Congrats" in s.posix.dumps(1))  # 找到会输出"Congrats"的状态（表示Congratulation？？？？）
<SimulationManager with 1 active, 1 found>

>>> s = simgr.found[0]
>>> print s.posix.dumps(1)
Enter password: Congrats!

>>> flag = s.posix.dumps(0)  # 输出在到达该状态的标准输入内容 ？？？？
>>> print(flag)
g00dJ0B!
 ```

### 5.5 Exploration Techniques

angr附带了几个固定功能，自定义模拟管理器的行为，称为`exploration techniques`。修改程序状态空间的模式 - “一次执行一步”策略实际上是广度优先搜索，但是可以使用`exploration techniques，`例如，实现深度优先搜索。 可以完全修改angr执行过程（step）的行为。

调用`simgr.use_technique(tech)`，其中`tech`是`ExplorationTechnique`子类的实例。` angr`的内置`exploration techniques`可以在`angr.exploration_techniques`下找到。 

一些内置`exploration techniques`：

- `Explorer`：此技术实现`.explore()`功能，允许您搜索和排除地址。 

- `DFS`：深度优先搜索。保持一次只有一个状态处于活动状态（active），将其余状态保持`deferred stash`，直到当前状态`deadends`或`errors`。 

- `LoopSeer`：使用一个**合理的近似循环计数**来丢弃似乎经过循环多次的状态，将它们置于一个`spinning stash`，如果其他可行的状态运行完毕，则将它们再次拉出（pull out）。

- `LengthLimiter`：在状态经过的路径的最大长度设置上限。 

- `ManualMergepoint`：将程序中的地址标记为合并点，因此将暂时保留到达该地址的状态，并且在超时时间内到达同一点的状态将合并在一起。

- ` Veritesting`：一个关于自动识别有用合并点的 [CMU paper](https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf) 的实现。在`SimulationManager`构造函数中使用`veritesting = True`自动启用！**请注意，由于其实现静态符号执行采用的侵入方式，它经常不能与其他技术一起使用。 **

- `Tracer`：一种探索技术，可以使`execution`遵循从其他来源记录的动态`trace`。[动态跟踪器存储库](http://angr.io/api-doc/angr.html#module-angr.sim_manager) 具有一些生成这些`trace`的工具。 

- `Oppologist`：“操作辩护者”("operation apologist" )是一个小工具 - 如果启用此技术并且angr遇到不受支持的指令，例如`bizzare`和外部浮点`SIMD`操作，它将具体化该指令的所有输入并模拟单个指令使用独角兽引擎（unicorn engine），允许继续执行 。？？？？

- `Threading` ：为步进过程（stepping process）添加线程级并行性。由于python的全局解释器锁定，这没有多大帮助，但是如果你有一个程序，其分析花费了很多时间在angr的本机代码依赖（unicorn，z3，libvex），你可能看起来有些收获。 ？？？？

- `Spiller`：当有太多状态处于活动状态（active）时，此技术可以将其中一些状态转储到磁盘，以便保持较低的内存消耗。 

[simulation manager API](http://angr.io/api-doc/angr.html#module-angr.manager)

[exploration techniques API](http://angr.io/api-doc/angr.html#angr.exploration_techniques.ExplorationTechnique)

## 6. Execution Engines

### 6.1 Simulation and Instrumentation

 angr使用一系列引擎（`SimEngine`类的子类）来模拟给定代码段对输入状态的影响。 angr的执行核心只是按顺序尝试所有可用的引擎，采用第一个能够处理该步骤的引擎。以下是按顺序的默认引擎列表 :

- 故障引擎（`failure engine`）：当前一步骤将我们带入一些不可持续的状态时，故障引擎就会启动 ；
- 系统调用引擎（`syscall engine `）：当前一步骤在系统调用中结束时，系统调用引擎启动 ；
- 钩子引擎（`hook engine`）：钩子引擎在当前地址被挂钩时启动 ；
- 独角兽引擎（`unicorn engine`）：当启用`UNICORN`状态选项且状态中没有符号数据时，独角兽引擎启动 ；
- VEX引擎（`VEX engine`）：VEX引擎成为最终的后备。

### 6.2 SimSuccessors

实际上依次尝试所有引擎的代码是`project.factory.successors(state，**kwargs)`，它将其参数传递给每个引擎。这个函数是`state.step()`和`simulation_manager.step()`的核心 。它返回一个`SimSuccessors`对象。 `SimSuccessors`的目的是对后继状态执行简单分类，存储在各种列表属性（list类型？） 。

属性如下：

| Attribute                           | Guard Condition                          | Instruction Pointer                                          | Descrption                                                   |
| ----------------------------------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `successors`                        | `True`（可以是符号，但约束为`True`）     | 可以是符号（但是256个或更少的解决方案;请参阅`unconstrained_successors`） | 引擎处理的状态（当前状态）的**正常、可满足的后继状态**。该状态的指令指针可以是符号的（即，基于用户输入的计算跳转），因此该状态实际上可能代表几个可能的`excution` |
| `unsat_successors`                  | `False`（可以是符号，但约束为`False`）。 | 可以是符号                                                   | **不可满足**的`successors`。这些是后继者，其保护条件只能是假的（即，不能采取的跳跃，或者必须采取的默认跳跃分支）。 |
| `flat_successors` ？？？？          | `True`（可以是符号，但约束为`True`）     | 具体数值（ Concrete value）                                  | 如上所述，`successors`列表中的`states`可以具有符号指令指针。我们假设单个程序状态仅表示代码中单个点的执行时，这是相当混乱的，就像代码中的其他地方一样（例如，在`SimEngineVEX.process`中，当它向前执行状态时）。为了缓解这种情况，当我们在后续符号中遇到带有符号指令指针的状态时，我们为它们计算所有可能的具体解决方案（最多为256的任意阈值），并为每个这样的解决方案制作状态的副本。我们称这个过程为“扁平化”。这些`flat_successors`是状态，每个状态都有一个不同的具体指令指针。例如，如果后继状态的指令指针是`X + 5`，其中`X`具有`X> 0x800000`和`X <0x800010`的约束，我们将其展平为16个不同的`flat_successors`状态，一个具有`0x800006`的指令指针，一个具有`0x800007`，依此类推，直到`0x800015`。 |
| `unconstrained_successors` ？？？？ | `True`（可以是符号，但约束为`True`）     | 符号（超过256个解决方案）                                    | 在上述扁平化过程期间，如果结果是指令指针有超过256种可能的解决方案，我们假设指令指针已被无约束数据覆盖（即，用户数据的堆栈溢出）。这种假设一般不合理。这些状态被放置在`unconstrained_successors`中而不是`successors`中。 |
| `all_successors`                    | Anything（符号/具体值，不限制约束）      | 可以是符号                                                   | `successors + unsat_successors + unconstrained_successors`.  |

### 6.3 Breakpoints ？？？？

```python
>>> import angr
>>> b = angr.Project('examples/fauxware/fauxware')

# get our state
>>> s = b.factory.entry_state()

# add a breakpoint. This breakpoint will drop into ipdb right before a memory write happens.
>>> s.inspect.b('mem_write')

# on the other hand, we can have a breakpoint trigger right *after* a memory write happens. 
# we can also have a callback function run instead of opening ipdb.
>>> def debug_func(state):
...     print "State %s is about to do a memory write!"

>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func)

# or, you can have it drop you in an embedded IPython!
>>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=angr.BP_IPYTHON)
```

可中断事件（event），都可以使用`BP_BEFORE`或`BP_AFTER`：

| Event type               | Event meaning                                            |
| ------------------------ | -------------------------------------------------------- |
| `mem_read`               | 即将读内存                                               |
| `mem_write`              | 即将写内存                                               |
| `reg_read`               | 即将读寄存器                                             |
| `reg_write`              | 即将写寄存器                                             |
| `tmp_read`               | 即将读`temp` ？？？？                                    |
| `tmp_write`              | 即将写`temp`                                             |
| `expr`                   | 即将创建一个表达式（例如， IR中的算术运算或常数的结果 ） |
| `statement`              | 即将翻译一条IR语句                                       |
| `instruction`            | 即将翻译一条新的（本机native)指令                        |
| `irsb`                   | 即将翻译一个新的基本块                                   |
| `constraints`            | 即将向`state`中加入一个`successor`                       |
| `exit`                   | 即将从`execution`中产生一个`successor`                   |
| `symbolic_variable`      | 即将产生一个符号变量                                     |
| `call`                   | 命中一条`call`指令                                       |
| `address_concretization` | 即将处理符号内存访问 ？？？？                            |

事件对应不同属性：

| Event type             | Attribute name                         | Attribute availability | Attribute meaning                                            |
| ---------------------- | -------------------------------------- | ---------------------- | ------------------------------------------------------------ |
| mem_read               | mem_read_address                       | BP_BEFORE or BP_AFTER  | The address at which memory is being read.                   |
| mem_read               | mem_read_length                        | BP_BEFORE or BP_AFTER  | The length of the memory read.                               |
| mem_read               | mem_read_expr                          | BP_AFTER               | The expression at that address.                              |
| mem_write              | mem_write_address                      | BP_BEFORE or BP_AFTER  | The address at which memory is being written.                |
| mem_write              | mem_write_length                       | BP_BEFORE or BP_AFTER  | The length of the memory write.                              |
| mem_write              | mem_write_expr                         | BP_BEFORE or BP_AFTER  | The expression that is being written.                        |
| reg_read               | reg_read_offset                        | BP_BEFORE or BP_AFTER  | The offset of the register being read.                       |
| reg_read               | reg_read_length                        | BP_BEFORE or BP_AFTER  | The length of the register read.                             |
| reg_read               | reg_read_expr                          | BP_AFTER               | The expression in the register.                              |
| reg_write              | reg_write_offset                       | BP_BEFORE or BP_AFTER  | The offset of the register being written.                    |
| reg_write              | reg_write_length                       | BP_BEFORE or BP_AFTER  | The length of the register write.                            |
| reg_write              | reg_write_expr                         | BP_BEFORE or BP_AFTER  | The expression that is being written.                        |
| tmp_read               | tmp_read_num                           | BP_BEFORE or BP_AFTER  | The number of the temp being read.                           |
| tmp_read               | tmp_read_expr                          | BP_AFTER               | The expression of the temp.                                  |
| tmp_write              | tmp_write_num                          | BP_BEFORE or BP_AFTER  | The number of the temp written.                              |
| tmp_write              | tmp_write_expr                         | BP_AFTER               | The expression written to the temp.                          |
| expr                   | expr                                   | BP_AFTER               | The value of the expression.                                 |
| statement              | statement                              | BP_BEFORE or BP_AFTER  | The index of the IR statement (in the IR basic block).       |
| instruction            | instruction                            | BP_BEFORE or BP_AFTER  | The address of the native instruction.                       |
| irsb                   | address                                | BP_BEFORE or BP_AFTER  | The address of the basic block.                              |
| constraints            | added_constraints                      | BP_BEFORE or BP_AFTER  | The list of constraint expressions being added.              |
| call                   | function_address                       | BP_BEFORE or BP_AFTER  | The name of the function being called.                       |
| exit                   | exit_target                            | BP_BEFORE or BP_AFTER  | The expression representing the target of a SimExit.         |
| exit                   | exit_guard                             | BP_BEFORE or BP_AFTER  | The expression representing the guard of a SimExit.          |
| exit                   | jumpkind                               | BP_BEFORE or BP_AFTER  | The expression representing the kind of SimExit.             |
| symbolic_variable      | symbolic_name                          | BP_BEFORE or BP_AFTER  | The name of the symbolic variable being created. The solver engine might modify this name (by appending a unique ID and length). Check the symbolic_expr for the final symbolic expression. |
| symbolic_variable      | symbolic_size                          | BP_BEFORE or BP_AFTER  | The size of the symbolic variable being created.             |
| symbolic_variable      | symbolic_expr                          | BP_AFTER               | The expression representing the new symbolic variable.       |
| address_concretization | address_concretization_strategy        | BP_BEFORE or BP_AFTER  | The SimConcretizationStrategy being used to resolve the address. This can be modified by the breakpoint handler to change the strategy that will be applied. If your breakpoint handler sets this to None, this strategy will be skipped. |
| address_concretization | address_concretization_action          | BP_BEFORE or BP_AFTER  | The SimAction object being used to record the memory action. |
| address_concretization | address_concretization_memory          | BP_BEFORE or BP_AFTER  | The SimMemory object on which the action was taken.          |
| address_concretization | address_concretization_expr            | BP_BEFORE or BP_AFTER  | The AST representing the memory index being resolved. The breakpoint handler can modify this to affect the address being resolved. |
| address_concretization | address_concretization_add_constraints | BP_BEFORE or BP_AFTER  | Whether or not constraints should/will be added for this read. |
| address_concretization | address_concretization_result          | BP_AFTER               | The list of resolved memory addresses (integers). The breakpoint handler can overwrite these to effect a different resolution result. |

在适当的断点回调期间，可以作为state.inspect的成员访问这些属性以访问适当的值。甚至可以修改这些值以修改值的进一步使用！ 

```python
>>> def track_reads(state):
...     print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address
...
>>> s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads)
```

此外，这些属性中的每一个都可以用作inspect.b的关键字参数，以使断点成为条件 :

```python
# This will break before a memory write if 0x1000 is a possible value of its target expression
>>> s.inspect.b('mem_write', mem_write_address=0x1000)

# This will break before a memory write if 0x1000 is the *only* value of its target expression
>>> s.inspect.b('mem_write', mem_write_address=0x1000, mem_write_address_unique=True)

# This will break after instruction 0x8000, but only 0x1000 is a possible value of the last expression that was read from memory
>>> s.inspect.b('instruction', when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000)
```

也可以将函数指定为条件：

```python
# this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and
# that the basic block starting at 0x8004 was executed sometime in this path's history
>>> def cond(state):
...     return state.eval(state.regs.rax, cast_to=str) == 'AAAA' and 0x8004 in state.inspect.backtrace

>>> s.inspect.b('mem_write', condition=cond)
```

### 6.4 `mem_read` breakpoint 注意事项

只要执行程序或二进制分析有内存读取，就会触发`mem_read`断点。如果在`mem_read`上使用断点并使用`state.mem`从内存地址加载数据，断点将在读取内存时被触发。 

**因此，如果要从内存加载数据而不触发已设置的任何`mem_read`断点，则使用`state.memory.load`和关键字参数`disable_actions = True`和`inspect = False`。**

对于`state.find`也是如此，可以使用相同的关键字参数来阻止激活`mem_read`断点 。

## 7. Analyses

angr的目标是辅助二进制程序分析。为此，angr允许以通用格式打包分析代码。所有分析都出现在`project.analyses`（例如，`project.analyses.CFGFast()`）下，并且可以作为函数调用，返回分析结果实例。 

扩展：[编写analyses](https://docs.angr.io/docs/analysis_writing.html)

### 7.1 内置Analyses

| Name                                                         | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| CFGFast                                                      | 构造一个快速控制流图                                         |
| [CFGAccurate](https://docs.angr.io/docs/analyses/cfg_accurate.html) | 构造一个精确控制流图                                         |
| VFG                                                          | 对程序的每个函数执行VSA（value-set-analyses），创建值流图（Value Flow Graph），探测栈变量？？？？ |
| DDG                                                          | 计算数据依赖关系图（Data DependencyGraph），确定给定值所依赖的语句 |
| [BackwardSlice](https://docs.angr.io/docs/analyses/backward_slice.html) | 针对特定目标计算程序的后向切片                               |
| [Identifier](https://docs.angr.io/docs/analyses/identifier.html) | 标识CGC二进制文件中的公共库函数 ？？？？                     |
| More!                                                        | angr has quite a few analyses, most of which work! If you'd like to know how to use one, please submit an issue requesting documentation. |

### 7.2 弹性

Analyses可以弹性处理，基本上可以捕获并记录任何错误。这些错误（取决于它们被捕获的方式）会被记录到`Analyses`的`errors`或`named_errors`属性中。若以“快速失败”（fail fast）模式运行分析，以便*不处理错误，*可以将参数`fail_fast = True`传递给分析构造函数。(将该参数传递给Analyses的构造函数 ？？？？) 

## 8. Remarks

angr只是一个模拟器。它是一个高度可用且非常独特的模拟器，对环境有很多考虑，但是在其核心，使用angr所做的工作是**提取有关一堆字节码如何在CPU上运行的知识**。

Angr可以用于集成，或者用于临时使用。